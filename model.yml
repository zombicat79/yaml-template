# Below follows a base example for a YAML configuration file with explanations

name: My Workflow #The 'name' key (strict) is the first one to be defined. It holds the name given to our Workflow
on: push #The 'on' key (strict) defines a trigger for our Workflow. Triggers can be manual or automatic. 'workflow_dispatch' is a manual trigger
# A multiplicity of trigger events can be specified by listing them in an array [trigger1, trigger2, triggern]
# A complete list of trigger events can be found on 'https://docs.github.com/en/actions/reference/workflows-and-actions/events-that-trigger-workflows'
# Trigger events can also be specified in a way that expresses more detailed or fine-grained control, as per shown below:
  pull_request: # This more ingrained syntax can be used instead of an array, when needing to define multiple triggers along with more nuanced config
    types: # Some trigger events can have different activity types (opened, closed, etc), which focus on specific types or statuses of the targeted event.
      # Activity types can be included in an array, but they can also be written in a list format:
      - opened
  workflow_dispatch: # Another trigger event (within a multiplicity of nuanced trigger events)
  push:
    branches: # Some trigger events can have different filters (branches, etc), which focus on specific parts or elements of the repository.
      # Pushes to the repository will only trigger the workflow if done against the branches listed below:
      - main
      - master
env: # #The 'env' key (strict) is used to store any environment variables that should be available across the entire workflow
  DATABASE_NAME: some_name #key-value pairs are entirely at our discretion
  # env variables can be stored as secrets in the repository settings
  # Reading environment variables later on can be achieved by using either of the following syntaxes:
  # $DATABASE_NAME
  # ${{ env.DATABASE_NAME }}
  # Using secrets in workflows can be achieved by specifing the following syntax as the value for the corresponding env variable: ${{ secrets.DATABASE_NAME }}
jobs: #The 'jobs' key (strict) is used to define the list of Jobs our Workflow comprises (at least 1)
#After the 'jobs' key indentation is required to define our list of Jobs
  first-job: #The actual name of the job is defined with a variable key (free choice, it can be anything we find most suitable)
  #After job names indentation is required to define job configurations
    environment: some_environment #The 'environment' key (strict) is used to reference a precise environment defined within the repository settings...
    # ...if present the env variables used will be those belonging to the referred environment
    env: # #The 'env' key (strict) can aldo be used at job level (even step), to store any environment variables that should be available only to that job
      DATABASE_ADDRESS: some_address #key-value pairs are entirely at our discretion
    runs-on: #The 'runs-on' key (strict) defines the machines and type of environments where our jobs and steps will be actually run (e. g. ubuntu-latest)
    steps: #The 'steps' key (strict) to define the list of Steps our Job comprises (at least 1)
    #After the 'steps' key indentation is required to define our list of Steps
    #Each step is preceded by a dash (-) symbol and a space
      - name: #The 'name' key (strict) holds the name given to our Step
        run: #The 'run' key (strict) contains a CLI command to be executed
      - name: 
        run: | #The pipe symbol (|) can be given in case several CLI commands must be run
        #CLI command 1 (with indentation)
        #CLI command 2 (with indentation)
      - name:
        uses: actions/checkout@v3 #The 'uses' key (strict) can be specified to run actions (pre-built common task applications) instead of CLI commands
        # A complete list of actions can be found on the marketplace 'https://github.com/marketplace?type=actions'
        with: #The 'with' key (strict) can be defined to fine-tune actions with some particular config options provided in their docs
          # config option keys must be indented
  second-job: # By default jobs are run in parallel (which is not always ideal, since some jobs should depend on the result of others)
    needs: #The 'needs' key (strict) makes a job run sequentially, after the job identifiers given as a value (e. g. first-job)
    #If a job depends on a multiplicity of other jobs, those must be included in an array [job1, job2, jobn]
    runs-on: #...
    steps: #...
      - name: #...
        run: #...
      - name:
        uses: actions/checkout@v3
        with: #...
          #...
